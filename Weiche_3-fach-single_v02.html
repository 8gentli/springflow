<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Materialfluss Simulation Weiche Batch vs Round-Robin</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a1a;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            overflow-x: hidden;
        }

        canvas {
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
            width: 1000px;
            margin-top: 15px;
            background: #333;
            padding: 15px;
            border-radius: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-size: 0.6rem;
            margin-bottom: 3px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stats-container {
            display: flex;
            gap: 20px;
            width: 1000px;
            margin-top: 10px;
        }

        .stats-box {
            flex: 1;
            font-family: monospace;
            background: #000;
            padding: 8px;
            border-radius: 4px;
            border-left: 4px solid #0f0;
            font-size: 0.85rem;
        }

        input[type=range],
        select {
            width: 100%;
            cursor: pointer;
            background: #444;
            color: white;
            border: 1px solid #555;
            padding: 3px;
        }

        span {
            font-size: 0.7em;
            color: #0af;
        }

        .button-row {
            grid-column: 1 / -1;
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
            border-top: 1px solid #555;
            padding-top: 10px;
        }

        button {
            padding: 10px 25px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            text-transform: uppercase;
            transition: 0.2s;
            min-width: 100px;
        }

        .btn-start {
            background: #28a745;
            color: white;
        }

        .btn-stop {
            background: #dc3545;
            color: white;
        }

        .btn-reset {
            background: #6c757d;
            color: white;
        }

        button:hover {
            opacity: 0.8;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .stats-table-container {
            width: 1000px;
            margin-top: 10px;
            background: #333;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            color: #eee;
            font-family: monospace;
            font-size: 0.85rem;
        }

        .stats-table th,
        .stats-table td {
            border: 1px solid #444;
            padding: 5px 8px;
            text-align: left;
        }

        .stats-table th {
            background: #222;
            color: #aaa;
            text-transform: uppercase;
            font-size: 0.7rem;
        }

        .stats-table tr:nth-child(even) {
            background: #2a2a2a;
        }

        .stats-table td.highlight {
            color: #0f0;
        }

        .stats-table td.warning {
            color: #ffa500;
        }

        .stats-table td.error {
            color: #f00;
        }

        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .stats-header h4 {
            margin: 0;
            color: #eee;
            font-weight: 400;
        }

        .time-input-group {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .time-input-group input {
            width: 70px;
            padding: 5px;
            background: #222;
            color: #eee;
            border: 1px solid #555;
            border-radius: 4px;
            text-align: center;
            font-family: monospace;
        }

        .time-input-group .arrow-buttons {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        .time-input-group .arrow-buttons button {
            background: #444;
            color: #eee;
            border: 1px solid #555;
            padding: 0px 1px;
            cursor: pointer;
            font-size: 8px;
            line-height: 1;
            border-radius: 2px;
            width: 10px;
            min-width: unset;
            height: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>

<body>

    <h3 style="margin: 5px 0; color: #eee; font-weight: 300;">Materialfluss Simulation Weiche Batch vs Round-Robin (3
        Pfade)</h3>
    <canvas id="simCanvas" width="1000" height="380"></canvas>

    <div class="stats-container">
        <div class="stats-box" id="globalStats">Zeit: 00:00 | Winder-Stopps: 0</div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Weichen-Logik</label>
            <select id="logicMode">
                <option value="Batch">Batch</option>
                <option value="RR">Round-Robin</option>
            </select>
        </div>
        <div class="control-group">
            <label>Sender-Takt (ppm)</label>
            <input type="range" id="senderPpm" min="40" max="60" value="55">
            <span id="senderPpmVal">55 ppm</span>
        </div>
        <div class="control-group">
            <label>Global Stopp (%)</label>
            <input type="range" id="probGlobal" min="0" max="100" value="4">
            <span id="probGlobalVal">4%</span>
        </div>
        <div class="control-group">
            <label>Min-Sensor (Federn)</label>
            <input type="range" id="minCap" min="1" max="10" value="5">
            <span id="minCapVal">5</span>
        </div>
        <div class="control-group">
            <label>Max-Sensor (Federn)</label>
            <input type="range" id="maxCap" min="1" max="15" value="10">
            <span id="maxCapVal">10</span>
        </div>
        <div class="control-group">
            <label>Pfad-Geschw.</label>
            <input type="range" id="pathSpeed" min="1" max="10" step="0.5" value="3">
            <span id="pathSpeedVal">3</span>
        </div>
        <div class="control-group">
            <label>Sim.-Tempo</label>
            <input type="range" id="simSpeed" min="1" max="50" step="1" value="1">
            <span id="simSpeedVal">1</span>
        </div>

        <div class="button-row">
            <button class="btn-start" onclick="toggleSim(true)">Start</button>
            <button class="btn-stop" onclick="toggleSim(false)">Stopp</button>
            <button class="btn-reset" onclick="resetSim()">Reset</button>
        </div>
    </div>

    <div style="width: 1000px; margin-top: 15px; background: #333; padding: 15px; border-radius: 8px;">
        <h4
            style="margin: 0 0 10px 0; color: #eee; font-weight: 300; border-bottom: 1px solid #555; padding-bottom: 5px;">
            Statistik & Prognose</h4>

        <!-- Input und Button oberhalb der Tabelle -->
        <div style="display: flex; gap: 10px; align-items: center; justify-content: center; margin-bottom: 15px;">
            <label style="color: #aaa; font-size: 0.85rem;">Zeitraum:</label>
            <div style="display: flex; align-items: center; gap: 3px;">
                <input type="text" id="statsDuration" value="01:00" placeholder="hh:mm"
                    style="width: 70px; padding: 5px; background: #222; color: #eee; border: 1px solid #555; border-radius: 4px; text-align: center; font-family: monospace;">
                <div style="display: flex; flex-direction: column; gap: 1px;">
                    <button onclick="adjustTime(30)"
                        style="background: #444; color: #eee; border: 1px solid #555; padding: 0px 1px; cursor: pointer; font-size: 8px; line-height: 1; border-radius: 2px; width: 10px;">▲</button>
                    <button onclick="adjustTime(-30)"
                        style="background: #444; color: #eee; border: 1px solid #555; padding: 0px 1px; cursor: pointer; font-size: 8px; line-height: 1; border-radius: 2px; width: 10px;">▼</button>
                </div>
            </div>
            <button onclick="calculateStats()"
                style="background: #0af; color: #000; padding: 8px 20px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer;">
                Statistik berechnen
            </button>
        </div>

        <!-- Tabelle mit erweiterten Spalten -->
        <div style="overflow-x: auto;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.75rem; color: #eee;">
                <thead>
                    <tr style="border-bottom: 1px solid #555; text-align: left;">
                        <th style="padding: 5px;">Zeitraum</th>
                        <th style="padding: 5px;">Winder-Stopps</th>
                        <th style="padding: 5px; color: #0f0;">OK</th>
                        <th style="padding: 5px; color: #f60;">MISS</th>
                        <th style="padding: 5px; color: #aaa;">Logik</th>
                        <th style="padding: 5px; color: #aaa;">PPM</th>
                        <th style="padding: 5px; color: #aaa;">Min-Sensor</th>
                        <th style="padding: 5px; color: #aaa;">Max-Sensor</th>
                        <th style="padding: 5px; color: #aaa;">Global Stopp %</th>
                        <th style="padding: 5px; color: #aaa;">Pfad-Geschw.</th>
                    </tr>
                </thead>
                <tbody id="statsBody">
                    <tr>
                        <td style="padding: 5px;" colspan="10">Keine Daten - Bitte "Statistik berechnen" klicken</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div
        style="margin-top: 25px; font-size: 0.8rem; color: #666; letter-spacing: 1px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">
        Vibe-Coded with <span style="color: #ff4d4d;">❤</span> and <span
            style="color: #0af; font-weight: bold;">Antigravity</span> by lindersi
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        const DOT_RADIUS = 4;
        const UNIT_SPACING = DOT_RADIUS * 2 + 3;
        const WEICHE_X = 180;
        const END_X = 820;
        const SOURCE_X = 50;
        const SENSOR_TIMEOUT = 500; // ms for sensor to become active

        let isRunning = true;
        let simState; // Renamed from 'state' to avoid conflict with global 'state'
        let statsHistory = [];
        let statsDurationMs = 60 * 1000; // Default 1 minute for stats calculation

        function init() {
            simState = {
                elapsedSimTime: 0,
                sourceStops: 0,
                sourceState: 'IDLE',
                lastSourceTime: 0,
                lockStartTime: 0,
                restartStartTime: 0,
                activeTargetId: -1,
                lastDistributedId: 0,
                pendingAfterStop: 0,
                lastActivePathId: 0,
                unitsSinceRestart: 0,
                globalDowntime: false,
                globalDowntimeUntil: 0,
                paths: Array.from({ length: 3 }, (_, i) => ({ // Auf 3 Pfade geaendert
                    id: i,
                    units: [],
                    isDown: false,
                    starvationTimer: 0,
                    lastTakeTime: 0,
                    missedUnits: 0,
                    processedUnits: 0,
                    y: 90 + i * 110, // Vertikaler Abstand angepasst
                    requestMaterial: true,
                    minSensorTimer: 0,
                    maxSensorTimer: 0,
                    minActive: false,
                    maxActive: false,
                    requestStartTime: 0,
                    // New fields for stats
                    downtimeStart: 0,
                    totalDowntime: 0,
                    waitingTimeStart: 0,
                    totalWaitingTime: 0,
                    lastUnitProcessedTime: 0,
                    lastUnitMissedTime: 0,
                    lastUnitSentTime: 0,
                    unitsSent: 0,
                    unitsAtMinSensor: 0,
                    unitsAtMaxSensor: 0,
                    lastMinSensorActive: false,
                    lastMaxSensorActive: false,
                }))
            };
            statsHistory = [];
            updateStatsDurationInput();
        }

        init();

        function toggleSim(val) { isRunning = val; }
        function resetSim() { init(); toggleSim(false); }

        const ui = (id) => document.getElementById(id);
        const simConfig = { // Renamed from 'config' to avoid conflict
            get logic() { return ui('logicMode').value; },
            get ppm() { return parseInt(ui('senderPpm').value); },
            get minCap() { return parseInt(ui('minCap').value); },
            get maxCap() { return parseInt(ui('maxCap').value); },
            get probGlobal() { return parseInt(ui('probGlobal').value); },
            get pathSpeed() { return parseFloat(ui('pathSpeed').value); },
            get speed() { return parseFloat(ui('simSpeed').value); }
        };

        ['senderPpm', 'pathSpeed', 'probGlobal', 'simSpeed', 'minCap', 'maxCap'].forEach(id => {
            ui(id).oninput = () => ui(id + 'Val').innerText = ui(id).value + (id.includes('prob') ? '%' : '');
        });

        ui('statsDuration').addEventListener('change', (e) => {
            const [minutes, seconds] = e.target.value.split(':').map(Number);
            if (!isNaN(minutes) && !isNaN(seconds) && minutes >= 0 && seconds >= 0 && seconds < 60) {
                statsDurationMs = (minutes * 60 + seconds) * 1000;
            } else {
                updateStatsDurationInput(); // Revert to current valid value
            }
        });

        function updateStatsDurationInput() {
            const totalSeconds = statsDurationMs / 1000;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            ui('statsDuration').value = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function adjustTime(deltaSeconds) {
            statsDurationMs = Math.max(0, statsDurationMs + deltaSeconds * 1000);
            updateStatsDurationInput();
        }

        function update() {
            if (!isRunning) return;
            let remainingDelta = 16.67 * simConfig.speed;
            const maxStep = 16.67;

            while (remainingDelta > 0) {
                const dt = Math.min(remainingDelta, maxStep);
                simulateStep(dt);
                remainingDelta -= dt;
            }
        }

        function simulateStep(dt) {
            runSimulationStep(simState, simConfig, dt);
        }

        function draw() {
            const now = simState.elapsedSimTime;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            simState.paths.forEach(p => {
                ctx.strokeStyle = p.requestMaterial ? 'rgba(0, 255, 0, 0.12)' : '#2a2a2a';
                ctx.lineWidth = 18; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(SOURCE_X, 190); ctx.lineTo(WEICHE_X, p.y); ctx.lineTo(END_X, p.y); ctx.stroke();

                const minX = END_X - (simConfig.minCap - 0.5) * UNIT_SPACING;
                const maxX = END_X - (simConfig.maxCap - 0.5) * UNIT_SPACING;
                drawSensor(minX, p.y, "MIN", p.minActive);
                drawSensor(maxX, p.y, "MAX", p.maxActive);

                p.units.forEach(u => {
                    let drawY = u.pos < WEICHE_X ? 190 + (p.y - 190) * Math.max(0, (u.pos - SOURCE_X) / (WEICHE_X - SOURCE_X)) : p.y;
                    ctx.fillStyle = (u.isPurge && u.isMoving) ? '#ff9999' : '#ddd';
                    ctx.beginPath(); ctx.arc(u.pos, drawY, DOT_RADIUS, 0, Math.PI * 2); ctx.fill();
                });

                const blocked = simState.globalDowntime || p.isDown;
                const starved = p.starvationTimer > now;
                ctx.fillStyle = starved ? '#ffa500' : (blocked ? '#f00' : '#0f0');
                if (starved) { ctx.shadowBlur = 15; ctx.shadowColor = '#ffa500'; }
                ctx.beginPath(); ctx.arc(END_X + 25, p.y, 12, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0;

                ctx.font = 'bold 12px monospace';
                ctx.fillStyle = '#0f0';
                ctx.fillText(`OK:   ${p.processedUnits}`, END_X + 50, p.y - 5);
                ctx.fillStyle = '#f60';
                ctx.fillText(`MISS: ${p.missedUnits}`, END_X + 50, p.y + 10);
            });

            let sCol = (simState.sourceState === 'ACTIVE' || simState.sourceState === 'BUFFER_STOP') ? '#0f0' : (simState.sourceState === 'LOCKED' ? '#f00' : (simState.sourceState === 'RESTART' ? '#ff0' : '#444'));
            ctx.fillStyle = sCol; ctx.shadowBlur = (sCol !== '#444') ? 15 : 0; ctx.shadowColor = sCol;
            ctx.fillRect(SOURCE_X - 20, 170, 40, 40); ctx.shadowBlur = 0;
            ctx.fillStyle = '#fff'; ctx.font = 'bold 10px Arial';
            ctx.fillText(simState.sourceState === 'ACTIVE' ? 'ACTIVE' : 'BUFFER STOP', SOURCE_X - 35, 165);

            const totalSecs = Math.floor(simState.elapsedSimTime / 1000);
            ui('globalStats').innerHTML = `Zeit: ${Math.floor(totalSecs / 60).toString().padStart(2, '0')}:${(totalSecs % 60).toString().padStart(2, '0')} | Winder-Stopps: ${simState.sourceStops}`;
        }

        function drawSensor(x, y, label, active) {
            ctx.fillStyle = active ? '#ff0' : '#444'; ctx.beginPath(); ctx.arc(x, y + 14, 3, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#777'; ctx.font = '7px Arial'; ctx.fillText(label, x - 6, y + 24);
        }

        function calculateStats() {
            const btn = document.querySelector('button[onclick="calculateStats()"]');
            const originalText = btn.innerText;
            btn.innerText = "Berechne...";
            btn.disabled = true;

            setTimeout(() => {
                const totalMinutes = statsDurationMs / 60000;

                // Snapshot current config
                const calcConfig = {
                    logic: simConfig.logic,
                    ppm: simConfig.ppm,
                    minCap: simConfig.minCap,
                    maxCap: simConfig.maxCap,
                    probGlobal: simConfig.probGlobal,
                    pathSpeed: simConfig.pathSpeed,
                    speed: 1
                };

                // Create simulation state FOR CALCULATION
                const calcState = {
                    elapsedSimTime: 0,
                    sourceStops: 0,
                    sourceState: 'IDLE',
                    lastSourceTime: 0,
                    lockStartTime: 0,
                    restartStartTime: 0,
                    activeTargetId: -1,
                    lastDistributedId: 0,
                    pendingAfterStop: 0,
                    lastActivePathId: 0,
                    unitsSinceRestart: 0,
                    globalDowntime: false,
                    globalDowntimeUntil: 0,
                    paths: Array.from({ length: 3 }, (_, i) => ({
                        id: i,
                        units: [],
                        isDown: false,
                        starvationTimer: 0,
                        lastTakeTime: 0,
                        missedUnits: 0,
                        processedUnits: 0,
                        y: 0,
                        requestMaterial: true,
                        minSensorTimer: 0,
                        maxSensorTimer: 0,
                        minActive: false,
                        maxActive: false,
                        requestStartTime: 0,
                        downtimeStart: 0,
                        totalDowntime: 0,
                        waitingTimeStart: 0,
                        totalWaitingTime: 0
                    }))
                };

                const dt = 16.67;
                const steps = Math.ceil(statsDurationMs / dt);

                for (let i = 0; i < steps; i++) {
                    runSimulationStep(calcState, calcConfig, dt);
                }

                const totalOK = calcState.paths.reduce((sum, p) => sum + p.processedUnits, 0);
                const totalMISS = calcState.paths.reduce((sum, p) => sum + p.missedUnits, 0);

                const displayHours = Math.floor(totalMinutes / 60);
                const displayMinutes = totalMinutes % 60;
                const timeDisplay = `${String(displayHours).padStart(2, '0')}:${String(displayMinutes).padStart(2, '0')}`;

                const tbody = document.getElementById('statsBody');
                if (tbody.children[0] && tbody.children[0].innerText.includes("Keine Daten")) {
                    tbody.innerHTML = "";
                }

                const row = document.createElement('tr');
                row.style.borderBottom = "1px solid #444";
                row.innerHTML = `
                    <td style="padding: 5px;">${timeDisplay}</td>
                    <td style="padding: 5px;">${calcState.sourceStops}</td>
                    <td style="padding: 5px; color: #0f0;">${totalOK}</td>
                    <td style="padding: 5px; color: #f60;">${totalMISS}</td>
                    <td style="padding: 5px; color: #aaa;">${calcConfig.logic}</td>
                    <td style="padding: 5px; color: #aaa;">${calcConfig.ppm}</td>
                    <td style="padding: 5px; color: #aaa;">${calcConfig.minCap}</td>
                    <td style="padding: 5px; color: #aaa;">${calcConfig.maxCap}</td>
                    <td style="padding: 5px; color: #aaa;">${calcConfig.probGlobal}%</td>
                    <td style="padding: 5px; color: #aaa;">${calcConfig.pathSpeed}</td>
                `;
                tbody.prepend(row);

                btn.innerText = originalText;
                btn.disabled = false;

            }, 50);
        }

        // Extracted simulation logic for both real-time and fast-forward
        function runSimulationStep(s, c, dt) {
            s.elapsedSimTime += dt;
            const now = s.elapsedSimTime;

            if (!s.globalDowntime && c.probGlobal > 0) {
                if (Math.random() < (0.0004 * (dt / 16.67) * (c.probGlobal / 20))) {
                    s.globalDowntime = true;
                    s.globalDowntimeUntil = now + 10000;
                }
            } else if (now > s.globalDowntimeUntil) {
                s.globalDowntime = false;
            }

            const cycleTime = 4700; // 4.7s fixed
            const isAnyPathDue = s.paths.some(p => now - p.lastTakeTime > cycleTime);

            if (isAnyPathDue) {
                const allReady = s.paths.every(p => p.units.length > 0 && p.units[0].pos >= END_X - DOT_RADIUS);

                s.paths.forEach(p => {
                    const isBlocked = s.globalDowntime;

                    if (!isBlocked) {
                        if (allReady) {
                            if (p.units.length > 0) p.units.shift();
                            p.processedUnits++;
                            p.isDown = false;
                            p.starvationTimer = 0;
                        } else {
                            p.missedUnits++;
                            p.starvationTimer = now + (cycleTime / 2);
                        }
                    } else {
                        p.isDown = true;
                        p.starvationTimer = 0;
                    }
                    p.lastTakeTime = now;
                });
            }

            s.paths.forEach(p => {
                for (let u of p.units) {
                    const targetPos = (p.units.indexOf(u) === 0) ? END_X : p.units[p.units.indexOf(u) - 1].pos - UNIT_SPACING;
                    if (u.pos < targetPos) {
                        u.pos += c.pathSpeed * (dt / 16.67);
                        u.isMoving = true;
                        if (u.pos >= targetPos) { u.pos = targetPos; u.isMoving = false; }
                    } else { u.isMoving = false; }
                }

                const minX = END_X - (c.minCap - 0.5) * UNIT_SPACING;
                const maxX = END_X - (c.maxCap - 0.5) * UNIT_SPACING;

                const isMinOccupied = p.units.some(u => Math.abs(u.pos - minX) < UNIT_SPACING * 0.6);
                const isMaxOccupied = p.units.some(u => Math.abs(u.pos - maxX) < UNIT_SPACING * 0.6);

                if (isMinOccupied) {
                    if (p.minSensorTimer === 0) p.minSensorTimer = now;
                    // if (now - p.minSensorTimer > SENSOR_TIMEOUT) p.minActive = true; // Wait for logic update
                } else { p.minSensorTimer = 0; p.minActive = false; }
                if (isMaxOccupied) {
                    if (p.maxSensorTimer === 0) p.maxSensorTimer = now;
                    if (now - p.maxSensorTimer > SENSOR_TIMEOUT) p.maxActive = true;
                } else { p.maxSensorTimer = 0; p.maxActive = false; }

                // Min Sensor Logic fix to match 4-fach
                // Actually 4-fach logic was:
                // if (isMinOccupied) { ... if > timeout p.minActive = true }
                // My previous edit in Weiche_3-fach had a syntax error in lines 477-479 (missing activation).
                if (isMinOccupied && now - p.minSensorTimer > SENSOR_TIMEOUT) p.minActive = true;

                const prevReq = p.requestMaterial;
                if (!p.minActive) p.requestMaterial = true;
                if (p.maxActive) p.requestMaterial = false;
                if (p.requestMaterial && !prevReq) p.requestStartTime = now;
                if (!p.requestMaterial) p.requestStartTime = 0;

                // Stats tracking
                if (p.isDown && p.downtimeStart === 0) p.downtimeStart = now;
                if (!p.isDown && p.downtimeStart !== 0) { p.totalDowntime += (now - p.downtimeStart); p.downtimeStart = 0; }
            });

            const anyReq = s.paths.some(p => p.requestMaterial);

            if (s.sourceState === 'ACTIVE' && !anyReq) {
                s.sourceState = 'BUFFER_STOP';
                s.pendingAfterStop = 3;
            } else if (s.sourceState === 'BUFFER_STOP' && s.pendingAfterStop <= 0) {
                s.sourceState = 'LOCKED';
                s.lockStartTime = now;
                s.sourceStops++;
            } else if (s.sourceState === 'LOCKED' && now - s.lockStartTime > 4000) {
                s.sourceState = 'IDLE';
            }

            if (s.sourceState === 'IDLE' && anyReq) {
                s.sourceState = 'RESTART';
                s.restartStartTime = now;
                s.unitsSinceRestart = 0;
            }

            if (s.sourceState === 'RESTART' && now - s.restartStartTime > 2000) {
                s.sourceState = anyReq ? 'ACTIVE' : 'IDLE';
            }

            const msPerUnit = (60000 / c.ppm);
            if (now - s.lastSourceTime > msPerUnit) {
                let tid = -1;
                if (c.logic === "Batch") {
                    if (s.activeTargetId !== -1 && !s.paths[s.activeTargetId].requestMaterial) s.activeTargetId = -1;
                    if (s.activeTargetId === -1 && anyReq) {
                        const reqPaths = s.paths.filter(p => p.requestMaterial && p.requestStartTime > 0);
                        if (reqPaths.length > 0) {
                            s.activeTargetId = reqPaths.sort((a, b) => a.requestStartTime - b.requestStartTime)[0].id;
                        } else {
                            s.activeTargetId = s.paths.find(p => p.requestMaterial).id;
                        }
                    }
                    tid = s.activeTargetId;
                } else {
                    for (let i = 1; i <= 3; i++) {
                        let checkId = (s.lastDistributedId + i) % 3;
                        if (s.paths[checkId].requestMaterial) { tid = checkId; break; }
                    }
                }

                if (s.sourceState === 'ACTIVE' && tid !== -1) {
                    s.unitsSinceRestart++;
                    if (s.unitsSinceRestart === 8) {
                        s.lastSourceTime = now;
                    } else {
                        s.paths[tid].units.push({ pos: SOURCE_X, isPurge: false });
                        s.lastDistributedId = tid; s.lastActivePathId = tid;
                        s.lastSourceTime = now;
                        if (c.logic === "RR") s.activeTargetId = -1;
                    }
                } else if (s.sourceState === 'BUFFER_STOP' && s.pendingAfterStop > 0) {
                    s.paths[s.lastActivePathId].units.push({ pos: SOURCE_X, isPurge: true });
                    s.pendingAfterStop--; s.lastSourceTime = now;
                }
            }
        }

        function frame() { update(); draw(); requestAnimationFrame(frame); }
        frame();
    </script>
</body>

</html>